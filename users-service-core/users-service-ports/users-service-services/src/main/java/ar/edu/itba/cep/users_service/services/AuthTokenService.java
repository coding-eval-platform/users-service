package ar.edu.itba.cep.users_service.services;

import ar.edu.itba.cep.roles.Role;
import ar.edu.itba.cep.users_service.models.AuthToken;
import ar.edu.itba.cep.users_service.models.SubjectAuthToken;
import ar.edu.itba.cep.users_service.models.User;
import ar.edu.itba.cep.users_service.models.UserAuthToken;
import com.bellotapps.webapps_commons.exceptions.NoSuchEntityException;
import com.bellotapps.webapps_commons.exceptions.UnauthenticatedException;
import com.bellotapps.webapps_commons.exceptions.UnauthorizedException;

import java.util.List;
import java.util.Set;
import java.util.UUID;

/**
 * A port into the application that allows {@link AuthToken} management.
 */
public interface AuthTokenService {

    /**
     * Creates a new {@link UserAuthToken} for the {@link User} with the given {@code username}, only if the given
     * {@code password} matches the said {@link User}'s credentials.
     *
     * @param username The {@link User}'s username.
     * @param password The {@link User}'s password.
     * @return A {@link RawTokenContainer} with the information generated by this action.
     * Will include the access token, together with a refresh token (is another token that can only be used to
     * refresh a token through the {@link AuthTokenService#refreshToken(UUID)} method).
     * @throws UnauthenticatedException If the given credentials do not match.
     */
    RawTokenContainer issueTokenForUser(final String username, final String password) throws UnauthenticatedException;

    /**
     * Creates a new {@link SubjectAuthToken} for the given {@code subject}.
     *
     * @param subject The subject to which the {@link SubjectAuthToken} must be issued.
     * @return A {@link RawTokenContainer} with the information generated by this action.
     * Will include the access token, together with a refresh token (is another token that can only be used to
     * refresh a token through the {@link AuthTokenService#refreshToken(UUID)} method).
     */
    RawTokenContainer issueTokenForSubject(final String subject, final Set<Role> roles);

    /**
     * Lists the {@link UserAuthToken}s of the {@link User} with the given {@code username}.
     *
     * @param username The {@link User}'s username.
     * @return A {@link List} containing the {@link UserAuthToken}s
     * that belong to the {@link User} with the given {@code username}.
     * @throws NoSuchEntityException If there is no {@link User} with the given {@code username}.
     */
    List<UserAuthToken> listUserTokens(final String username) throws NoSuchEntityException;

    /**
     * Lists the {@link SubjectAuthToken}s with the given {@code subject}.
     *
     * @param subject The subject to match.
     * @return A {@link List} containing the matching {@link SubjectAuthToken}s.
     */
    List<SubjectAuthToken> listSubjectTokens(final String subject) throws NoSuchEntityException;

    /**
     * Refreshes the {@link AuthToken} with the given {@code id}.
     *
     * @param id The token's id.
     * @return A {@link RawTokenContainer} with the new information of the token.
     * Will include a new refresh token.
     * @throws UnauthorizedException If the {@link AuthToken} with the given {@code id} was invalidated,
     *                               or if the {@link User} owning such {@link AuthToken} is not active.
     * @apiNote This method can only be executed when the refresh token is presented.
     */
    RawTokenContainer refreshToken(final UUID id) throws UnauthorizedException;

    /**
     * Blacklists the {@link AuthToken} with the given {@code id}.
     * Note that once a token is blacklisted, the associated refresh token won't be
     *
     * @param id The token's id.
     */
    void blacklistToken(final UUID id);
}
